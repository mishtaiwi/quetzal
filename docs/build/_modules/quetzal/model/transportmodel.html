<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>quetzal.model.transportmodel &mdash; quetzal  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> quetzal
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quetzal.engine.html">quetzal.engine package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quetzal.model.html">quetzal.model package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quetzal.io.html">quetzal.io package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quetzal.analysis.html">quetzal.analysis package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">quetzal</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>quetzal.model.transportmodel</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for quetzal.model.transportmodel</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">quetzal.analysis</span> <span class="kn">import</span> <span class="n">analysis</span>
<span class="kn">from</span> <span class="nn">quetzal.engine</span> <span class="kn">import</span> <span class="n">engine</span><span class="p">,</span> <span class="n">nested_logit</span>
<span class="kn">from</span> <span class="nn">quetzal.engine.park_and_ride_pathfinder</span> <span class="kn">import</span> <span class="n">ParkRidePathFinder</span>
<span class="kn">from</span> <span class="nn">quetzal.engine.pathfinder</span> <span class="kn">import</span> <span class="n">PublicPathFinder</span>
<span class="kn">from</span> <span class="nn">quetzal.engine.road_pathfinder</span> <span class="kn">import</span> <span class="n">RoadPathFinder</span>
<span class="kn">from</span> <span class="nn">quetzal.model</span> <span class="kn">import</span> <span class="n">model</span><span class="p">,</span> <span class="n">optimalmodel</span><span class="p">,</span> <span class="n">parkridemodel</span>
<span class="kn">from</span> <span class="nn">syspy.assignment</span> <span class="kn">import</span> <span class="n">raw</span> <span class="k">as</span> <span class="n">raw_assignment</span>
<span class="kn">from</span> <span class="nn">syspy.assignment.raw</span> <span class="kn">import</span> <span class="n">fast_assign</span> <span class="k">as</span> <span class="n">assign</span>
<span class="kn">from</span> <span class="nn">syspy.skims</span> <span class="kn">import</span> <span class="n">skims</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>


<div class="viewcode-block" id="read_hdf"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.read_hdf">[docs]</a><span class="k">def</span> <span class="nf">read_hdf</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read HDF format</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filepath : string</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">m</span> <span class="o">=</span> <span class="n">TransportModel</span><span class="p">()</span>
    <span class="n">m</span><span class="o">.</span><span class="n">read_hdf</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="read_json"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.read_json">[docs]</a><span class="k">def</span> <span class="nf">read_json</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read json format</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    folder : string</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _type_</span>
<span class="sd">        _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">m</span> <span class="o">=</span> <span class="n">TransportModel</span><span class="p">()</span>
    <span class="n">m</span><span class="o">.</span><span class="n">read_json</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span></div>


<span class="n">track_args</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">track_args</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">log</span>


<div class="viewcode-block" id="TransportModel"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel">[docs]</a><span class="k">class</span> <span class="nc">TransportModel</span><span class="p">(</span><span class="n">optimalmodel</span><span class="o">.</span><span class="n">OptimalModel</span><span class="p">,</span> <span class="n">parkridemodel</span><span class="o">.</span><span class="n">ParkRideModel</span><span class="p">):</span>
<div class="viewcode-block" id="TransportModel.step_distribution"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.step_distribution">[docs]</a>    <span class="nd">@track_args</span>
    <span class="k">def</span> <span class="nf">step_distribution</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">segmented</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">deterrence_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">od_volume_from_zones_kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function performing distribution of flows with doubly constrained algorithm,</span>
<span class="sd">        based on an impedance/deterrence matrix inversely proportional to the accessibility between two zones.</span>
<span class="sd">        </span>
<span class="sd">        Requires :</span>
<span class="sd">            * self.zones</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segmented : bool, optional</span>
<span class="sd">            if True: all parameters must be given in dict {segment: param}, by default False</span>
<span class="sd">        deterrence_matrix : unstacked dataframe, optional</span>
<span class="sd">            an OD unstaked dataframe representing the disincentive to</span>
<span class="sd">            travel as distance/time/cost increases, by default None</span>
<span class="sd">        od_volume_from_zones_kwargs : </span>
<span class="sd">            if the friction matrix is not</span>
<span class="sd">            provided, it will be automatically computed using a gravity distribution with</span>
<span class="sd">                - power: int, thee gravity exponent</span>
<span class="sd">                - intrazonal: (bool) if False set the intrazonal distance to 0, else compute a characteristic distance</span>
<span class="sd">         </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.volumes :</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">segmented</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="s1">&#39;destination&#39;</span><span class="p">])</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">od_volume_from_zones_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;deterrence_matrix&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;deterrence_matrix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deterrence_matrix</span> <span class="k">if</span> <span class="n">deterrence_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="s1">&#39;power&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;power&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="s1">&#39;intrazonal&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;intrazonal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
                <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;emission&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;attraction&#39;</span><span class="p">)]</span>
                <span class="k">if</span> <span class="s1">&#39;area&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="p">:</span>
                    <span class="n">cols</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">]</span>
                <span class="n">segment_zones</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="p">{</span>
                        <span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;emission&#39;</span><span class="p">):</span> <span class="s1">&#39;emission&#39;</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;attraction&#39;</span><span class="p">):</span> <span class="s1">&#39;attraction&#39;</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="n">segment_volumes</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">od_volume_from_zones</span><span class="p">(</span>
                    <span class="n">segment_zones</span><span class="p">,</span>
                    <span class="n">deterrence_matrix</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;deterrence_matrix&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="n">coordinates_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates_unit</span><span class="p">,</span>
                    <span class="n">power</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;power&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                    <span class="n">intrazonal</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;intrazonal&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">segment_volumes</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;volume&#39;</span><span class="p">:</span> <span class="n">segment</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">segment_volumes</span><span class="p">,</span>
                    <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="s1">&#39;destination&#39;</span><span class="p">],</span>
                    <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">od_volume_from_zones</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="p">,</span>
                <span class="n">deterrence_matrix</span><span class="p">,</span>
                <span class="n">coordinates_unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates_unit</span><span class="p">,</span>
                <span class="o">**</span><span class="n">od_volume_from_zones_kwargs</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="TransportModel.step_road_pathfinder"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.step_road_pathfinder">[docs]</a>    <span class="nd">@track_args</span>
    <span class="k">def</span> <span class="nf">step_road_pathfinder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfw&#39;</span><span class="p">,</span> <span class="n">maxiters</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
       
        <span class="sd">&quot;&quot;&quot;Performs road assignment with or without capacity constraint, depending on the method used</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.road_links</span>
<span class="sd">            * self.zone_to_road</span>
<span class="sd">            * self.volumes </span>

<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : [&#39;bfw&#39;|&#39;fw&#39;|&#39;msa&#39;|&#39;aon&#39;], optional</span>
<span class="sd">            Which method to use for pathfinder. Options are:</span>

<span class="sd">            &#39;bfw&#39;   --(default) </span>

<span class="sd">            &#39;fw&#39;    --</span>

<span class="sd">            &#39;msa&#39;   -- </span>

<span class="sd">            &#39;aon&#39;   -- all or nothing : shortest path pathfinder</span>
<span class="sd">            </span>
<span class="sd">        maxiters : integer, optional, default 10</span>
<span class="sd">            Maxiters=1 will perform &#39;shortest path&#39; pathfinder</span>

<span class="sd">        tolerance  : float, optional, default 0.01</span>
<span class="sd">            stop condition for RelGap, in percent </span>

<span class="sd">        volume_column : string, optional, default &#39;volume_car&#39;</span>
<span class="sd">            column of self.volumes to use for volume </span>

<span class="sd">        ntleg_penalty : float, optional, default 1e9</span>
<span class="sd">            ntleg penality for access time </span>

<span class="sd">        access_time : string, optional, default &#39;time&#39;</span>
<span class="sd">            column for time in zone_to_road for access time </span>

<span class="sd">        od_set : dict, optional</span>
<span class="sd">            set of od to use - may be used to reduce computation time (default None)</span>
<span class="sd">            for example, the od_set is the set of od for which there is a volume in self.volumes</span>

<span class="sd">        num_cores : integer, optional, default 1</span>
<span class="sd">            for parallelization</span>

<span class="sd">        log : </span>
<span class="sd">            log data on each iteration (default False)</span>

<span class="sd">        vdf : dict, optional</span>
<span class="sd">            dict of function for the jam time : {&#39;default_bpr&#39;: default_bpr,&#39;limited_bpr&#39;:limited_bpr, &#39;free_flow&#39;: free_flow} </span>

<span class="sd">        beta : list, optional, default None</span>
<span class="sd">            give constant value for BFW betas. ex: [0.7,0.2,0.1].</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.car_los :</span>
<span class="sd">            create tables of car levels of services</span>

<span class="sd">        self.road_links :</span>
<span class="sd">            add columns flow (volume on the road links) and jam_time (time of the link with congestion)</span>
<span class="sd">            for each OD pair results of pathfinder with/without capacity restriction</span>

<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="n">roadpathfinder</span> <span class="o">=</span> <span class="n">RoadPathFinder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="s1">&#39;all_or_nothing&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;all_or_nothing&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;aon&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &#39;all_or_nothing&#39;=True is deprecated. use method = &#39;aon&#39; instead&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;msa&#39;</span><span class="p">,</span><span class="s1">&#39;fw&#39;</span><span class="p">,</span><span class="s1">&#39;bfw&#39;</span><span class="p">,</span><span class="s1">&#39;aon&#39;</span><span class="p">]:</span>
            <span class="n">roadpathfinder</span><span class="o">.</span><span class="n">msa</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">maxiters</span><span class="o">=</span><span class="n">maxiters</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">car_los</span> <span class="o">=</span> <span class="n">roadpathfinder</span><span class="o">.</span><span class="n">car_los</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;aon&#39;</span><span class="p">:</span> <span class="c1"># do not overwrite road_links if its all-or-nothing</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span> <span class="o">=</span> <span class="n">roadpathfinder</span><span class="o">.</span><span class="n">road_links</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relgap</span> <span class="o">=</span> <span class="n">roadpathfinder</span><span class="o">.</span><span class="n">relgap</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">method</span><span class="p">,</span><span class="s1">&#39; not supported. use msa, fw, bfw or aon&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">car_los</span><span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">car_los</span><span class="p">[</span><span class="s1">&#39;destination&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="TransportModel.step_pr_pathfinder"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.step_pr_pathfinder">[docs]</a>    <span class="nd">@track_args</span>
    <span class="k">def</span> <span class="nf">step_pr_pathfinder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">path_analysis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Park and Ride pathfinder algorithm : shortest path algorithm on the graph</span>
<span class="sd">        built from links (public transport routes) and road_links considered as &quot;public transport access links&quot; (with car speed).</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.zones </span>
<span class="sd">            * self.links </span>
<span class="sd">            * self.footpaths </span>
<span class="sd">            * self.zone_to_road </span>
<span class="sd">            * self.zone_to_transit </span>
<span class="sd">            * self.transit_to_zone </span>
<span class="sd">            * self.road_to_transit </span>
<span class="sd">            * self.road_links </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        force : bool, optional, default False</span>
<span class="sd">            If True, will NOT perform integrity_test_collision on the &#39;nodes&#39;, &#39;links&#39;, &#39;zones&#39;,&#39;road_nodes&#39;, &#39;road_links&#39;.</span>

<span class="sd">        path_analysis : bool, optional, default True</span>
<span class="sd">            Performs paths analysis, adds columns &#39;all_walk&#39; and &#39;ntransfers&#39; to the output pt_los</span>

<span class="sd">        od_set : dict, optional, default None</span>
<span class="sd">            set of od to use - may be used to reduce computation time (default None)</span>
<span class="sd">            for example, the od_set is the set of od for which there is a volume in self.volumes</span>

<span class="sd">        cutoff : default np.inf     </span>
<span class="sd">            description</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.pr_los </span>

<span class="sd">        &quot;&quot;&quot;</span>    


        <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">,</span> <span class="s1">&#39;links&#39;</span><span class="p">,</span> <span class="s1">&#39;zones&#39;</span><span class="p">,</span> <span class="s1">&#39;road_nodes&#39;</span><span class="p">,</span> <span class="s1">&#39;road_links&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integrity_test_collision</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">graph_links</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>
        <span class="n">parkridepathfinder</span> <span class="o">=</span> <span class="n">ParkRidePathFinder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">parkridepathfinder</span><span class="o">.</span><span class="n">find_best_path</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pr_los</span> <span class="o">=</span> <span class="n">parkridepathfinder</span><span class="o">.</span><span class="n">paths</span>

        <span class="k">if</span> <span class="n">path_analysis</span><span class="p">:</span>
            <span class="n">analysis_nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">road_nodes</span><span class="p">])</span>
            <span class="n">analysis_links</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pr_los</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">path_analysis_od_matrix</span><span class="p">(</span>
                <span class="n">od_matrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pr_los</span><span class="p">,</span>
                <span class="n">links</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span>
                <span class="n">nodes</span><span class="o">=</span><span class="n">analysis_nodes</span><span class="p">,</span>
                <span class="n">centroids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centroids</span><span class="p">,</span>
            <span class="p">)</span>  <span class="c1"># analyse non vérifiée, prise directement depuis pt_los</span></div>

<div class="viewcode-block" id="TransportModel.step_pt_pathfinder"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.step_pt_pathfinder">[docs]</a>    <span class="nd">@track_args</span>
    <span class="k">def</span> <span class="nf">step_pt_pathfinder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">broken_routes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">broken_modes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">route_column</span><span class="o">=</span><span class="s1">&#39;route_id&#39;</span><span class="p">,</span>
        <span class="n">mode_column</span><span class="o">=</span><span class="s1">&#39;route_type&#39;</span><span class="p">,</span>
        <span class="n">boarding_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">speedup</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">walk_on_road</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="c1"># keep_graph=False,</span>
        <span class="n">keep_pathfinder</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">path_analysis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs public transport pathfinder.</span>
<span class="sd">        </span>
<span class="sd">        With :</span>
<span class="sd">            - all or nothing Diskjstra algorithm if broken_routes=False AND broken_modes=False</span>
<span class="sd">            - Prunning algorithm if broken_routes=True OR/AND broken_modes=True</span>
<span class="sd">        For optimal strategy pathfinder, use step_pt_pathfinder of the class OptimalModel</span>

<span class="sd">        For connection scan pathfinder algorithm (with time tables), use step_pt_pathfinder of the class ConnectionScanModel.</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.zones</span>
<span class="sd">            * self.links</span>
<span class="sd">            * self.footpaths</span>
<span class="sd">            * self.zone_to_road</span>
<span class="sd">            * self.zone_to_transit</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        broken_routes : bool, optional, default True</span>
<span class="sd">            If True, will perform the route breaker of the pathfinder prunning algorithm</span>
<span class="sd">            with the different routes found in the route_column </span>

<span class="sd">        broken_modes : bool, optional, default True</span>
<span class="sd">            If True, will perform the mode breaker of the pathfinder prunning algorithm</span>
<span class="sd">            with the different modes found in the mode_column</span>

<span class="sd">        route_column : str, optional, default &#39;route_id&#39;</span>
<span class="sd">            columns of the self.links containing the routes identifier (prunning algorithm)</span>

<span class="sd">        mode_column : str, optional, default &#39;route_type&#39;</span>
<span class="sd">            columns of the self.links containing the modes identifier (prunning algorithm)</span>

<span class="sd">        boarding_time : float, optional, default None</span>
<span class="sd">            aditional boarding time </span>

<span class="sd">        alighting_time : float, optional, default None</span>
<span class="sd">            aditional alighting time </span>

<span class="sd">        speedup : bool, optional, default False</span>
<span class="sd">            Speed up the computation time, by </span>

<span class="sd">        walk_on_road : bool, optional, default False</span>
<span class="sd">            If True, will consider using the road network and zone_to_road for pedestrian paths.</span>
<span class="sd">            Warning : it will only compare those paths using the raod network with the paths using pedestrian links (footpaths, zone_to_transit) </span>
<span class="sd">            Force the use of road network for pedestrian paths by NOT defining footpaths and zone_to_transit</span>

<span class="sd">        keep_pathfinder : bool, optional, default False</span>
<span class="sd">            If True, keeps all computation steps of the pathfinder</span>
<span class="sd">            Use to performed advanced route and mode breaker (without the need to create submodel for route_breaker, for example) </span>

<span class="sd">        force : bool, optional, default False</span>
<span class="sd">            If True, will NOT perform integrity_test_collision on the &#39;nodes&#39;, &#39;links&#39;, &#39;zones&#39;,&#39;road_nodes&#39;, &#39;road_links&#39;.</span>

<span class="sd">        path_analysis : bool, optional, default True</span>
<span class="sd">            Performs paths analysis, adds columns &#39;all_walk&#39; and &#39;ntransfers&#39; to the output pt_los</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.pt_los :</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">,</span> <span class="s1">&#39;links&#39;</span><span class="p">,</span> <span class="s1">&#39;zones&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">walk_on_road</span><span class="p">:</span>
            <span class="n">sets</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;road_nodes&#39;</span><span class="p">,</span> <span class="s1">&#39;road_links&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integrity_test_collision</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">graph_links</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">)</span>

        <span class="n">publicpathfinder</span> <span class="o">=</span> <span class="n">PublicPathFinder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">walk_on_road</span><span class="o">=</span><span class="n">walk_on_road</span><span class="p">)</span>
        <span class="n">publicpathfinder</span><span class="o">.</span><span class="n">find_best_paths</span><span class="p">(</span>
            <span class="n">broken_routes</span><span class="o">=</span><span class="n">broken_routes</span><span class="p">,</span>
            <span class="n">broken_modes</span><span class="o">=</span><span class="n">broken_modes</span><span class="p">,</span>
            <span class="n">route_column</span><span class="o">=</span><span class="n">route_column</span><span class="p">,</span>
            <span class="n">mode_column</span><span class="o">=</span><span class="n">mode_column</span><span class="p">,</span>
            <span class="n">speedup</span><span class="o">=</span><span class="n">speedup</span><span class="p">,</span>
            <span class="n">boarding_time</span><span class="o">=</span><span class="n">boarding_time</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># if keep_graph:</span>
        <span class="c1">#     self.nx_graph=publicpathfinder.nx_graph</span>

        <span class="k">if</span> <span class="n">keep_pathfinder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">publicpathfinder</span> <span class="o">=</span> <span class="n">publicpathfinder</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pt_los</span> <span class="o">=</span> <span class="n">publicpathfinder</span><span class="o">.</span><span class="n">paths</span>
        <span class="n">analysis_nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">road_nodes</span><span class="p">])</span> <span class="k">if</span> <span class="n">walk_on_road</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>

        <span class="k">if</span> <span class="n">path_analysis</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pt_los</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">path_analysis_od_matrix</span><span class="p">(</span>
                <span class="n">od_matrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pt_los</span><span class="p">,</span>
                <span class="n">links</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span>
                <span class="n">nodes</span><span class="o">=</span><span class="n">analysis_nodes</span><span class="p">,</span>
                <span class="n">centroids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centroids</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="TransportModel.step_modal_split"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.step_modal_split">[docs]</a>    <span class="nd">@track_args</span>
    <span class="k">def</span> <span class="nf">step_modal_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">build_od_stack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">modal_split_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs modal split. Use only for simple models with the modes Public Transport and Car,</span>
<span class="sd">        with few details : only based on duration and modal penalties.</span>
<span class="sd">        Based on modes demand and levels of services, it returns the volume by mode.</span>
<span class="sd">        Does not include price. </span>
<span class="sd">        For modal split, prefer the use of function step_logit</span>
<span class="sd">        </span>
<span class="sd">            * Utility(car) = alpha_car * &#39;duration_car&#39; + beta_car</span>
<span class="sd">            * Utility(pt) = &#39;duration_pt&#39;</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.volumes : all mode origin-&gt;destination demand matrix</span>
<span class="sd">            * self.los : levels of service. An od stack matrix with &#39;duration_pt&#39; and &#39;duration_car&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        build_od_stack : bool, optional</span>
<span class="sd">            _description_, by default True</span>

<span class="sd">        time_scale : float</span>
<span class="sd">            time scale of the logistic regression that compares utilities. Defines selectiveness.</span>
<span class="sd">            Defined as 1/(utility value of time, in seconds)</span>

<span class="sd">        alpha_car : float</span>
<span class="sd">            multiplicative penalty on &#39;duration_car&#39; for the calculation of &#39;utility_car&#39;</span>

<span class="sd">        beta_car : float</span>
<span class="sd">            additive penalty on &#39;duration_car&#39; for the calculation of &#39;utility_car&#39;</span>
<span class="sd">        </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.od_stack :</span>
<span class="sd">        self.shared :</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ::</span>
<span class="sd">            los = pd.merge(</span>
<span class="sd">                car_los,</span>
<span class="sd">                pt_los,</span>
<span class="sd">                on=[&#39;origin&#39;, &#39;destination&#39;],</span>
<span class="sd">                suffixes=[&#39;_car&#39;, &#39;_pt&#39;]</span>
<span class="sd">            )</span>
<span class="sd">            </span>
<span class="sd">            sm.step_modal_split(</span>
<span class="sd">                time_scale=1/1800,</span>
<span class="sd">                alpha_car=2,</span>
<span class="sd">                beta_car=600</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shared</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">modal_split_from_volumes_and_los</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="p">,</span>
            <span class="o">**</span><span class="n">modal_split_kwargs</span>
        <span class="p">)</span>
        <span class="c1"># shared[&#39;distance_car&#39;] = shared[&#39;distance&#39;]</span>
        <span class="k">if</span> <span class="n">build_od_stack</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">od_stack</span> <span class="o">=</span> <span class="n">analysis</span><span class="o">.</span><span class="n">volume_analysis_od_matrix</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shared</span> <span class="o">=</span> <span class="n">shared</span></div>

<div class="viewcode-block" id="TransportModel.compute_los_volume"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.compute_los_volume">[docs]</a>    <span class="k">def</span> <span class="nf">compute_los_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_expanded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_segments</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute volumes in the level of services table from volumes and probabilities</span>
<span class="sd">        computed in the step_logit.</span>

<span class="sd">        Requires</span>
<span class="sd">            * self.los : concatenation of levels of services of the different modes (usually pt_los and car_los)</span>
<span class="sd">            * self.volumes </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_expanded : bool, optional, default False</span>
<span class="sd">            Use True for models using timetables and ConnectionScan models </span>
<span class="sd">        keep_segments : bool, optional, default True</span>
<span class="sd">            True to use model segments - compute volumes per path per segment</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.los :</span>
<span class="sd">            add volume column </span>

<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">los</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">time_expanded</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">te_los</span>

        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]</span>

        <span class="n">shared_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">los</span><span class="o">.</span><span class="n">columns</span><span class="p">)))</span>
        <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">shared_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="s1">&#39;destination&#39;</span><span class="p">,</span> <span class="s1">&#39;wished_departure_time&#39;</span><span class="p">]]</span>

        <span class="n">left</span> <span class="o">=</span> <span class="n">los</span><span class="p">[</span><span class="n">on</span> <span class="o">+</span> <span class="n">probabilities</span><span class="p">]</span>
        <span class="n">left</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">los</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">probabilities</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">df</span><span class="p">[</span><span class="n">segments</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
            <span class="n">los</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">los</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_expanded</span><span class="p">:</span>
            <span class="n">los_volumes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te_los</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;path_id&#39;</span><span class="p">)[[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">segments</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">path_id_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="p">[</span><span class="s1">&#39;path_id&#39;</span><span class="p">])</span>
            <span class="n">volume_values</span> <span class="o">=</span> <span class="n">los_volumes</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">path_id_list</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">los_volumes</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>  <span class="c1"># create_columns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">los_volumes</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_values</span></div>

<div class="viewcode-block" id="TransportModel.step_assignment"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.step_assignment">[docs]</a>    <span class="k">def</span> <span class="nf">step_assignment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">road</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">boardings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">boarding_links</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">alightings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">alighting_links</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">transfers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">segmented</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">time_expanded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">compute_los_volume</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs assignment : compute the volumes on the links of the public transport network,</span>
<span class="sd">        and the boardings and alightings on the nodes of the PT network.</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.los : concatenation of levels of services of the different modes (usually pt_los and car_los)</span>
<span class="sd">            * self.volumes </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        road : bool, optional, default False</span>
<span class="sd">            Assign car volume.</span>
<span class="sd">            If road_link_list exists (columns of self.links computed with preparation_cast_network function)</span>
<span class="sd">            Add public transport volume on road_links.</span>
<span class="sd">            Requires </span>
<span class="sd">        boardings : bool, optional, default False</span>
<span class="sd">            If True, compute boardings to add to the nodes dataframe</span>
<span class="sd">        boarding_links : bool, optional, default False</span>
<span class="sd">            If True, compute boardings to add to the links dataframe</span>
<span class="sd">        alightings : bool, optional, default False</span>
<span class="sd">            If True, compute alightings to add to the nodes dataframe</span>
<span class="sd">        alighting_links : bool, optional, default False</span>
<span class="sd">            If True, compute alightings to add to the links dataframe</span>
<span class="sd">        transfers : bool, optional, default False</span>
<span class="sd">            If True, compute number of transfers to add to the nodes dataframe</span>
<span class="sd">        segmented : bool, optional, default False</span>
<span class="sd">            If True, use model segments - compute volumes on the links per segment</span>
<span class="sd">        time_expanded : bool, optional, default False</span>
<span class="sd">            Use True for models using timetables and ConnectionScan models </span>
<span class="sd">        compute_los_volume : bool, optional, default True</span>
<span class="sd">            True to add column volumes in los dataframe</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.los :</span>
<span class="sd">            add volume column if compute_los_volume=True</span>
<span class="sd">        self.links :</span>
<span class="sd">            add volumes on public transport links, can add boardings, alightings,</span>
<span class="sd">            can be per segment, depending on parameters</span>
<span class="sd">        self.nodes : </span>
<span class="sd">            Depending on parameters, add boardings, alightings, transfers</span>
<span class="sd">        self.road_links : </span>
<span class="sd">            add public transport volumes on road_links if road=True</span>
<span class="sd">        &quot;&quot;&quot;</span>    

   
        <span class="k">if</span> <span class="n">compute_los_volume</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_los_volume</span><span class="p">(</span><span class="n">time_expanded</span><span class="o">=</span><span class="n">time_expanded</span><span class="p">)</span>
        <span class="n">los</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;link_path&#39;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">road</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[(</span><span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="s1">&#39;car&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
            <span class="k">if</span> <span class="s1">&#39;road_link_list&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">to_assign</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="s1">&#39;road_link_list&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[(</span><span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="s1">&#39;pt&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span>
                    <span class="n">to_assign</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">],</span>
                    <span class="n">to_assign</span><span class="p">[</span><span class="s1">&#39;road_link_list&#39;</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">boardings</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">boarding_links</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;to assign boardings on links pass boarding_links=True&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">boarding_links</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;boarding_links&#39;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;boardings&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">boardings</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;boardings&#39;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;boardings&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">alighting_links</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;alighting_links&#39;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;alightings&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">alightings</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;alightings&#39;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;alightings&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">transfers</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;transfers&#39;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;transfers&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">segmented</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segmented_assigment</span><span class="p">(</span>
                <span class="n">road</span><span class="o">=</span><span class="n">road</span><span class="p">,</span>
                <span class="n">boardings</span><span class="o">=</span><span class="n">boardings</span><span class="p">,</span> <span class="n">alightings</span><span class="o">=</span><span class="n">alightings</span><span class="p">,</span> <span class="n">transfers</span><span class="o">=</span><span class="n">transfers</span><span class="p">,</span>
                <span class="n">aggregated_los</span><span class="o">=</span><span class="n">los</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="TransportModel.segmented_assigment"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.segmented_assigment">[docs]</a>    <span class="k">def</span> <span class="nf">segmented_assigment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">road</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">boardings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">alightings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">transfers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">aggregated_los</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs assignment per segment : compute the volumes on the links of the public transport network,</span>
<span class="sd">        and the boardings and alightings on the nodes of the PT network, </span>
<span class="sd">        keeping the memory of segments in the volumes.</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.los : concatenation of levels of services of the different modes (usually pt_los and car_los)</span>
<span class="sd">            * self.volumes </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        road : bool, optional, default False</span>
<span class="sd">            Add public transport volume on road_links.</span>
<span class="sd">            Requires road_link_list - columns of self.links computed with preparation_cast_network function.</span>

<span class="sd">        boardings : bool, optional, default False</span>
<span class="sd">            If True, compute boardings to add to the nodes dataframe</span>
<span class="sd">        </span>
<span class="sd">        alightings : bool, optional, default False</span>
<span class="sd">            If True, compute alightings to add to the nodes dataframe</span>
<span class="sd">        </span>
<span class="sd">        transfers : bool, optional, default False</span>
<span class="sd">            If True, compute number of transfers to add to the nodes dataframe</span>
<span class="sd">        </span>
<span class="sd">        aggregated_los : string, optional, default None</span>
<span class="sd">            Name of attributes containing model aggregated los</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.los :</span>
<span class="sd">            add volume column if compute_los_volume=True</span>
<span class="sd">        self.links :</span>
<span class="sd">            add volumes on public transport links per segment,</span>
<span class="sd">            can add boardings, alightings,depending on parameters</span>
<span class="sd">        self.nodes : </span>
<span class="sd">            Depending on parameters, add boardings, alightings, transfers</span>
<span class="sd">        self.road_links : </span>
<span class="sd">            add public transport volumes on road_links if road=True</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="n">los</span> <span class="o">=</span> <span class="n">aggregated_los</span> <span class="k">if</span> <span class="n">aggregated_los</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;link_path&#39;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">segment</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">road</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;car&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">segment</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;pt&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="n">segment</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;road_link_list&#39;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">boardings</span><span class="p">:</span>
                <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;boarding_links&#39;</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;boardings&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">segment</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

                <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;boardings&#39;</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;boardings&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">segment</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">alightings</span><span class="p">:</span>
                <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;alighting_links&#39;</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;alightings&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">segment</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

                <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;alightings&#39;</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;alightings&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">segment</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">transfers</span><span class="p">:</span>
                <span class="n">column</span> <span class="o">=</span> <span class="s1">&#39;transfers&#39;</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">los</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">column</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;transfers&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assign</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">segment</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">column</span><span class="p">])</span></div>

<div class="viewcode-block" id="TransportModel.step_pt_assignment"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.step_pt_assignment">[docs]</a>    <span class="nd">@track_args</span>
    <span class="k">def</span> <span class="nf">step_pt_assignment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">volume_column</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">on_road_links</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">split_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs assignment of the indicated volume column: compute the volumes on the links of the public transport network,</span>
<span class="sd">        and the boardings and alightings on the nodes of the PT network.</span>
<span class="sd">        This function is older and slower, will soon be deprecated, if possible priviledge the use of function step_assigment.</span>
<span class="sd">        Compared to step_assignment : </span>
<span class="sd">            - uses pt_los (and not los)</span>
<span class="sd">            - Can specify the volume column</span>
<span class="sd">            - Can strack path categories</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.links</span>
<span class="sd">            * self.nodes</span>
<span class="sd">            * self.pt_los : requires computed path probabilities in pt_los for each segment,</span>
<span class="sd">              they can be computed with funcions analysis_mode_utility + step_logit</span>
<span class="sd">            * self.road_links</span>
<span class="sd">            * self.volumes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        volume_column : string, optional, default None</span>
<span class="sd">           volume column of self.volumes to assign. If none, all columns will be assigned</span>
<span class="sd">        on_road_links : bool, optional, default False</span>
<span class="sd">            if True, performs pt assignment on road_links as well</span>
<span class="sd">        split_by : string, optional, default None</span>
<span class="sd">            path categories to be tracked in the assignment. Must be a column of self.pt_los</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.loaded_links</span>
<span class="sd">        self.loaded_nodes</span>
<span class="sd">        self.road_links :</span>
<span class="sd">            add public transport load column </span>

<span class="sd">        example:</span>
<span class="sd">        ::</span>
<span class="sd">            sm.step_assignment(</span>
<span class="sd">                    volume_column=None,</span>
<span class="sd">                    on_road_links=False,</span>
<span class="sd">                    split_by=&#39;route_type&#39;,</span>
<span class="sd">                    boardings=True,</span>
<span class="sd">                    alightings=True,</span>
<span class="sd">                    transfers=True</span>
<span class="sd">                }</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">volume_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segmented_pt_assignment</span><span class="p">(</span>
                <span class="n">on_road_links</span><span class="o">=</span><span class="n">on_road_links</span><span class="p">,</span>
                <span class="n">split_by</span><span class="o">=</span><span class="n">split_by</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># When split_by is not None, this call could be replaced by a sum, provided</span>
        <span class="c1"># prior dumb definition of loaded_links and loaded_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">loaded_links_and_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">volumes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">,</span>
            <span class="n">path_finder_stack</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pt_los</span><span class="p">,</span>
            <span class="n">volume_column</span><span class="o">=</span><span class="n">volume_column</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Rename columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">volume_column</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="n">volume_column</span><span class="p">)},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">volume_column</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="n">volume_column</span><span class="p">)},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;boardings&#39;</span><span class="p">,</span> <span class="s1">&#39;alightings&#39;</span><span class="p">,</span> <span class="s1">&#39;transfers&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">volume_column</span><span class="p">)},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">volume_column</span><span class="p">)},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Group assignment</span>
        <span class="k">if</span> <span class="n">split_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt_los</span><span class="p">[</span><span class="n">split_by</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="c1"># TODO remove rows with empty link_path</span>
                <span class="n">group_pt_los</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt_los</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pt_los</span><span class="p">[</span><span class="n">split_by</span><span class="p">]</span> <span class="o">==</span> <span class="n">group</span><span class="p">]</span>
                <span class="n">group_loaded_links</span><span class="p">,</span> <span class="n">group_loaded_nodes</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">loaded_links_and_nodes</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
                    <span class="n">volumes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">,</span>
                    <span class="n">path_finder_stack</span><span class="o">=</span><span class="n">group_pt_los</span><span class="p">,</span>
                    <span class="n">volume_column</span><span class="o">=</span><span class="n">volume_column</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
                <span class="c1"># Append results columns</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="p">[(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="n">volume_column</span><span class="p">,</span> <span class="n">group</span><span class="p">)]</span> <span class="o">=</span> <span class="n">group_loaded_links</span><span class="p">[</span><span class="n">volume_column</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span><span class="p">[(</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="n">volume_column</span><span class="p">,</span> <span class="n">group</span><span class="p">)]</span> <span class="o">=</span> <span class="n">group_loaded_nodes</span><span class="p">[</span><span class="n">volume_column</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;boardings&#39;</span><span class="p">,</span> <span class="s1">&#39;alightings&#39;</span><span class="p">,</span> <span class="s1">&#39;transfers&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">volume_column</span><span class="p">,</span> <span class="n">group</span><span class="p">)]</span> <span class="o">=</span> <span class="n">group_loaded_links</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">volume_column</span><span class="p">,</span> <span class="n">group</span><span class="p">)]</span> <span class="o">=</span> <span class="n">group_loaded_nodes</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>

        <span class="c1"># Assignment on road_links</span>
        <span class="k">if</span> <span class="n">on_road_links</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;road_link_path&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt_los</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># create road_link_path column from networkcasted linkss if not already defined</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_analysis_road_link_path</span><span class="p">()</span>

            <span class="n">merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pt_los</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="s1">&#39;destination&#39;</span><span class="p">])</span>
            <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;to_assign&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[(</span><span class="n">volume_column</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="n">merged</span><span class="p">[</span><span class="n">volume_column</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">split_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">assign_group</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">raw_assignment</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;to_assign&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;road_link_path&#39;</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">result</span>
                <span class="n">group_assigned</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">split_by</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">assign_group</span><span class="p">)</span>
                <span class="n">assigned</span> <span class="o">=</span> <span class="n">group_assigned</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Add empty groups</span>
                <span class="k">for</span> <span class="n">empty</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">assigned</span><span class="o">.</span><span class="n">columns</span><span class="p">))):</span>
                    <span class="n">assigned</span><span class="p">[</span><span class="n">empty</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[[(</span><span class="n">volume_column</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]]</span> <span class="o">=</span> <span class="n">assigned</span><span class="p">[[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[</span><span class="n">volume_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">assigned</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># no groups</span>
                <span class="n">assigned</span> <span class="o">=</span> <span class="n">raw_assignment</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;to_assign&#39;</span><span class="p">],</span> <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;road_link_path&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[</span><span class="n">volume_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">assigned</span><span class="p">[</span><span class="s1">&#39;volume&#39;</span><span class="p">]</span>

            <span class="c1"># todo remove &#39;load&#39; from analysis module:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[</span><span class="s1">&#39;load&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[</span><span class="n">volume_column</span><span class="p">]</span></div>

<div class="viewcode-block" id="TransportModel.segmented_pt_assignment"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.segmented_pt_assignment">[docs]</a>    <span class="k">def</span> <span class="nf">segmented_pt_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">on_road_links</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs pt assignment for all demand segments. Function used in step_pt_assignment function,</span>
<span class="sd">        refer to this function for other args.</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.links</span>
<span class="sd">            * self.nodes</span>
<span class="sd">            * self.pt_los : requires computed path probabilities in pt_los for each segment</span>
<span class="sd">            * self.road_links</span>
<span class="sd">            * self.volumes</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        on_road_links : bool, optional, default False</span>
<span class="sd">            if True, performs pt assignment on road_links as well</span>
<span class="sd">        split_by : string, optional, default None</span>
<span class="sd">            path categories to be tracked in the assignment. Must be a column of self.pt_los</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.loaded_links</span>
<span class="sd">        self.loaded_nodes</span>
<span class="sd">        self.road_links :</span>
<span class="sd">            add public transport load column </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span>

        <span class="n">iterator</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="n">iterator</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
            <span class="c1"># Assign demand segment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">step_pt_assignment</span><span class="p">(</span>
                <span class="n">volume_column</span><span class="o">=</span><span class="n">segment</span><span class="p">,</span>
                <span class="n">path_pivot_column</span><span class="o">=</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">),</span>
                <span class="n">split_by</span><span class="o">=</span><span class="n">split_by</span><span class="p">,</span>
                <span class="n">on_road_links</span><span class="o">=</span><span class="n">on_road_links</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
            <span class="c1"># Update links and nodes to keep results as loaded links and nodes</span>
            <span class="c1"># are erased at each call of step_pt_assignment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span>

        <span class="c1"># Group assignment results: sum over demand segments</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pt_los</span><span class="p">[</span><span class="n">split_by</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;load&#39;</span><span class="p">]</span>
        <span class="c1"># Add boardings, alightings and transfers if processed</span>
        <span class="n">cols</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;boardings&#39;</span><span class="p">,</span> <span class="s1">&#39;alightings&#39;</span><span class="p">,</span> <span class="s1">&#39;transfers&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">col</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">g</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">col</span><span class="p">,</span> <span class="n">g</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">col</span><span class="p">,</span> <span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loaded_links</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loaded_nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">on_road_links</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[(</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">group</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[[(</span><span class="n">s</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="o">.</span><span class="n">drop</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[</span><span class="s1">&#39;load&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="TransportModel.step_car_assignment"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.step_car_assignment">[docs]</a>    <span class="k">def</span> <span class="nf">step_car_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volume_column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs car assignment of the indicated volume column: compute the volumes on the road_links of the private transport network.</span>
<span class="sd">        This function is older and slower, will soon be deprecated, priviledge the use of function step_assigment and step_road_pathfinder.</span>
<span class="sd">        Compared to step_assignment : </span>
<span class="sd">            - uses car_los (and not los)</span>
<span class="sd">            - Can specify the volume column</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.road_links</span>
<span class="sd">            * self.road_nodes</span>
<span class="sd">            * self.car_los : requires computed path probabilities in car_los for each segment,</span>
<span class="sd">            they can be computed with funcions analysis_mode_utility + step_logit</span>
<span class="sd">            * self.volumes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        volume_column : string, optional, default None</span>
<span class="sd">           volume column of self.volumes to assign. If none, all columns will be assigned</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.loaded_road_links</span>
<span class="sd">        self.loaded_road_nodes</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">volume_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">segmented_car_assignment</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">car_los</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="s1">&#39;destination&#39;</span><span class="p">])</span>
            <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;to_assign&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[(</span><span class="n">volume_column</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="n">merged</span><span class="p">[</span><span class="n">volume_column</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">assigned</span> <span class="o">=</span> <span class="n">raw_assignment</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;to_assign&#39;</span><span class="p">],</span> <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;link_path&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[(</span><span class="n">volume_column</span><span class="p">,</span> <span class="s1">&#39;car&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assigned</span></div>

<div class="viewcode-block" id="TransportModel.segmented_car_assignment"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.segmented_car_assignment">[docs]</a>    <span class="k">def</span> <span class="nf">segmented_car_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs car assignment for all demand segments. Function used in step_car_assignment function,</span>
<span class="sd">        refer to this function for other args and parameters.</span>
<span class="sd">        </span>
<span class="sd">        Requires :</span>
<span class="sd">            * self.road_links</span>
<span class="sd">            * self.road_nodes</span>
<span class="sd">            * self.car_los : requires computed path probabilities in car_los for each segment</span>
<span class="sd">            * self.volumes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.loaded_road_links</span>
<span class="sd">        self.loaded_road_nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">segments</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="n">iterator</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">car_los</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="s1">&#39;destination&#39;</span><span class="p">])</span>
            <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;to_assign&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="n">merged</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">assigned</span> <span class="o">=</span> <span class="n">raw_assignment</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">merged</span><span class="p">[</span><span class="s1">&#39;to_assign&#39;</span><span class="p">],</span> <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;link_path&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;car&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">assigned</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;car&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[(</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;car&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">road_links</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>
        <span class="c1"># TODO Merge conflict: TO CHECK WITH ACCRA</span>
        <span class="c1"># self.road_links.drop(columns, 1, inplace=True)</span>
        <span class="c1"># if not &#39;load&#39; in self.road_links.columns:</span>
        <span class="c1">#    self.road_links[&#39;load&#39;] = 0</span>
        <span class="c1"># self.road_links[&#39;load&#39;] += self.road_links[(&#39;all&#39;,&#39;car&#39;)]</span>

    <span class="c1"># TODO move all utility features to another object / file</span>

<div class="viewcode-block" id="TransportModel.analysis_mode_utility"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.analysis_mode_utility">[docs]</a>    <span class="k">def</span> <span class="nf">analysis_mode_utility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">segments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_expanded</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute utilities per mode per segment based on logit parameters.</span>
<span class="sd">        </span>
<span class="sd">        Before applying this function :</span>
<span class="sd">            -- the function preparation_logit allows to create the </span>
<span class="sd">                stepmodel attributes utility_values, logit_scales, mode_utility and mode_nests </span>
<span class="sd">                required in the analysis_mode_utility function</span>
<span class="sd">            -- the functions analysis_pt_route_type and analysis_car_route_type may also be needed</span>
<span class="sd">                to builds &#39;route_type&#39; in pt_los (resp in car_los) based on &#39;route_types&#39;</span>
<span class="sd">            -- concatenate pt_los and car_los</span>

<span class="sd">        The function analysis_mode_utility computes the utility based on the chosen variables of the utility </span>
<span class="sd">        functions. The coefficients of the variable in the utility fonctions must be found in the utility_values model attribute </span>
<span class="sd">        and in the columns of the model los (default : price, time, ntransfers). They can be defined by segment.</span>
<span class="sd">        The modal constant can also be defined per segment and must be found in the table mode_utility.</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.mode_utility</span>
<span class="sd">            * self.los</span>
<span class="sd">            * self.utility_values </span>
<span class="sd">            * self.segments</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        how : [&#39;main&#39;|&#39;min&#39;|&#39;max&#39;|&#39;mean&#39;|&#39;sum&#39;], optional, default &#39;min&#39;</span>
<span class="sd">            What type of agregation for mode constant. Options are:</span>

<span class="sd">            &#39;main&#39;   --(default)  the utility (constant) of the &#39;route_type&#39; is used</span>

<span class="sd">            &#39;min&#39;    -- minimum of the utilities (constant) of the modes in route_types</span>

<span class="sd">            &#39;max&#39;   -- maximum of the utilities (constant) of the modes in route_types</span>

<span class="sd">            &#39;mean&#39;   -- mean of the utilities (constant) of the modes in route_types</span>

<span class="sd">            &#39;sum&#39;   -- sum of the utilities (constant) of the modes in route_types</span>

<span class="sd">        segment : string, optional, default None</span>
<span class="sd">            Unique segment for which to compute utility. If None, will perform for all segments of self.segments</span>
<span class="sd">        segments : list, optional, default None</span>
<span class="sd">            List of segments of the model for which to compute utility</span>
<span class="sd">        time_expanded : bool, optional, default False</span>
<span class="sd">            Use True for models using timetables and ConnectionScan models </span>
<span class="sd">        </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.los :</span>
<span class="sd">            add columns (segment, &#39;utility&#39;) - value of the utility per segment </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">segment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_mode_utility</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="n">segment</span><span class="p">,</span> <span class="n">time_expanded</span><span class="o">=</span><span class="n">time_expanded</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">time_expanded</span><span class="p">:</span>
            <span class="n">logit_los</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te_los</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logit_los</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span>
        <span class="n">mode_utility</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_utility</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;main&#39;</span><span class="p">:</span> <span class="c1"># the utility of the &#39;route_type&#39; is used</span>
            <span class="n">logit_los</span><span class="p">[</span><span class="s1">&#39;mode_utility&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">logit_los</span><span class="p">[</span><span class="s1">&#39;route_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">mode_utility</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span> <span class="c1"># how = &#39;min&#39;, &#39;max&#39;, &#39;mean&#39;, &#39;sum&#39;</span>
            <span class="c1"># route type utilities</span>
            <span class="n">rtu</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">rt</span><span class="p">:</span> <span class="n">get_combined_mode_utility</span><span class="p">(</span>
                    <span class="n">rt</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">mode_utility</span><span class="o">=</span><span class="n">mode_utility</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">rt</span> <span class="ow">in</span> <span class="n">logit_los</span><span class="p">[</span><span class="s1">&#39;route_types&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">logit_los</span><span class="p">[</span><span class="s1">&#39;mode_utility&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">logit_los</span><span class="p">[</span><span class="s1">&#39;route_types&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">rtu</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>

        <span class="n">utility_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility_values</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">utility_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">u</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">logit_los</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">logit_los</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;utility&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">logit_los</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;utility&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">logit_los</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;utility&#39;</span><span class="p">)]</span></div>

<div class="viewcode-block" id="TransportModel.analysis_utility"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.analysis_utility">[docs]</a>    <span class="k">def</span> <span class="nf">analysis_utility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="n">time_expanded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DEPRECATED USE analysis_mode_utility</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">segment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analysis_mode_utility</span><span class="p">(</span><span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="n">segment</span><span class="p">,</span> <span class="n">time_expanded</span><span class="o">=</span><span class="n">time_expanded</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">time_expanded</span><span class="p">:</span>
            <span class="n">los</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te_los</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">los</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span>

        <span class="n">utility_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility_values</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">utility_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">u</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">los</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">los</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;utility&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">los</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;utility&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">los</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;utility&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></div>

<div class="viewcode-block" id="TransportModel.initialize_logit"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.initialize_logit">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_logit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Not necessary</span>
<span class="sd">        creates tables od_probabilities and od_utilities</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="n">zones</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zones</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">od</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_product</span><span class="p">([</span><span class="n">zones</span><span class="p">,</span> <span class="n">zones</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">od_probabilities</span> <span class="o">=</span> <span class="n">od</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">od_utilities</span> <span class="o">=</span> <span class="n">od</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="TransportModel.step_logit"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.TransportModel.step_logit">[docs]</a>    <span class="k">def</span> <span class="nf">step_logit</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time_expanded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">decimals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n_paths_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nchunks</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">keep_od_tables</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs the nested logit : compute the probabilities per segment of the paths in self.los </span>
<span class="sd">        after having computed the utilities with function analysis_mode_utility.</span>
<span class="sd">        prob(mode k)= exp(utility mode k)/sum(utilities, all modes).</span>
<span class="sd">        Parametrize the nested logit with model attribute mode_nests and logit_scales </span>
<span class="sd">        created with function preparation_logit.</span>

<span class="sd">        Requires :</span>
<span class="sd">            * self.mode_nests</span>
<span class="sd">            * self.logit_scales</span>
<span class="sd">            * self.los</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_expanded : bool, optional, default False</span>
<span class="sd">            Use True for models using timetables and ConnectionScan models</span>
<span class="sd">        decimals : float, optional, default None</span>
<span class="sd">            minimum probability (avoid very small volumes)</span>
<span class="sd">        n_paths_max : int, optional, default None</span>
<span class="sd">            Maximum number of paths to keep per OD (avoid very small volumes)</span>
<span class="sd">        nchunks : int, optional, default 10</span>
<span class="sd">            Parameter to speed up computation time (division of calculation)</span>
<span class="sd">        workers : int, optional, default 1</span>
<span class="sd">            Parameter to speed up computation time (division of calculation)</span>
<span class="sd">        keep_od_tables : bool, optional, default True</span>
<span class="sd">            _description_, by default True</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self.los </span>
<span class="sd">            Add columns (segment, &#39;probability&#39;) of probabilities per segment</span>
<span class="sd">        self.od_utilities</span>
<span class="sd">        self.od_probabilities</span>
<span class="sd">        self.path_utilities</span>
<span class="sd">        self.path_probabilities</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># concatenate paths</span>
        <span class="n">od_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="s1">&#39;destination&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">time_expanded</span><span class="p">:</span>
            <span class="n">od_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;wished_departure_time&#39;</span><span class="p">)</span>
        <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="n">keep_columns</span> <span class="o">=</span> <span class="n">od_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;route_type&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;utility&#39;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">time_expanded</span><span class="p">:</span>
                <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">te_los</span><span class="p">[</span><span class="n">keep_columns</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="p">[</span><span class="n">keep_columns</span><span class="p">]</span>

            <span class="n">paths</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;utility&#39;</span><span class="p">):</span> <span class="s1">&#39;utility&#39;</span><span class="p">},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">paths</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;utility&#39;</span><span class="p">])</span>
            <span class="n">paths</span><span class="p">[</span><span class="s1">&#39;segment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">segment</span>
            <span class="n">to_concat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="n">segmented_paths</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">to_concat</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># all the segments can be proccessed together</span>
            <span class="c1"># assert all logit scales are the same and pick one</span>
            <span class="n">logit_scales</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logit_scales</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">logit_scales</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">logit_scales</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;root&#39;</span><span class="p">]</span>
            <span class="n">nls</span> <span class="o">=</span> <span class="n">logit_scales</span><span class="p">[</span><span class="s1">&#39;root&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

            <span class="c1"># assert all mode_nests are the same and pick one</span>
            <span class="n">mode_nests</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_nests</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mode_nests</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">mode_nests</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;root&#39;</span><span class="p">]</span>
            <span class="n">nests</span> <span class="o">=</span> <span class="n">mode_nests</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;root&#39;</span><span class="p">)[</span><span class="s1">&#39;route_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

            <span class="n">p</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mp</span> <span class="o">=</span> <span class="n">nested_logit</span><span class="o">.</span><span class="n">nested_logit_from_paths</span><span class="p">(</span>
                <span class="n">segmented_paths</span><span class="p">,</span>
                <span class="n">od_cols</span><span class="p">,</span>
                <span class="n">mode_nests</span><span class="o">=</span><span class="n">nests</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">nls</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">,</span> <span class="n">n_paths_max</span><span class="o">=</span><span class="n">n_paths_max</span><span class="p">,</span>
                <span class="n">nchunks</span><span class="o">=</span><span class="n">nchunks</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span>
                <span class="n">return_od_tables</span><span class="o">=</span><span class="n">keep_od_tables</span>
            <span class="p">)</span>

        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="n">p_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mu_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mp_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                <span class="n">mode_nests</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_nests</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">segment</span><span class="p">)[</span><span class="s1">&#39;route_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
                <span class="n">nls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logit_scales</span><span class="p">[</span><span class="n">segment</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
                <span class="n">paths</span> <span class="o">=</span> <span class="n">segmented_paths</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">segmented_paths</span><span class="p">[</span><span class="s1">&#39;segment&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">segment</span><span class="p">]</span>
                <span class="n">p</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">mp</span> <span class="o">=</span> <span class="n">nested_logit</span><span class="o">.</span><span class="n">nested_logit_from_paths</span><span class="p">(</span>
                    <span class="n">paths</span><span class="p">,</span>
                    <span class="n">mode_nests</span><span class="o">=</span><span class="n">mode_nests</span><span class="p">,</span>
                    <span class="n">phi</span><span class="o">=</span><span class="n">nls</span><span class="p">,</span>
                    <span class="n">od_cols</span><span class="o">=</span><span class="n">od_cols</span><span class="p">,</span>
                    <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">,</span>
                    <span class="n">n_paths_max</span><span class="o">=</span><span class="n">n_paths_max</span><span class="p">,</span>

                <span class="p">)</span>
                <span class="n">p_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">mu_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
                <span class="n">mp_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">p_list</span><span class="p">)</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">mu_list</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">mp_list</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;segment&#39;</span><span class="p">,</span> <span class="s1">&#39;index&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">time_expanded</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">te_los</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">segment</span><span class="p">][</span><span class="s1">&#39;probability&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">,</span> <span class="s2">&quot;los must have unique index&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">los</span><span class="p">[(</span><span class="n">segment</span><span class="p">,</span> <span class="s1">&#39;probability&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">segment</span><span class="p">][</span><span class="s1">&#39;probability&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">probabilities</span> <span class="o">=</span> <span class="n">mp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utilities</span> <span class="o">=</span> <span class="n">mu</span></div></div>


<div class="viewcode-block" id="get_combined_mode_utility"><a class="viewcode-back" href="../../../quetzal.model.transportmodel.html#quetzal.model.transportmodel.get_combined_mode_utility">[docs]</a><span class="k">def</span> <span class="nf">get_combined_mode_utility</span><span class="p">(</span><span class="n">route_types</span><span class="p">,</span> <span class="n">mode_utility</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Agregate modal constants</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    route_types : list</span>
<span class="sd">        List of the route_types in the path </span>
<span class="sd">    mode_utility : dataframe</span>
<span class="sd">        Modal constants</span>
<span class="sd">    how : [&#39;main&#39;|&#39;min&#39;|&#39;max&#39;|&#39;mean&#39;|&#39;sum&#39;], optional, default &#39;min&#39;</span>
<span class="sd">            What type of agregation for mode constant. Options are:</span>

<span class="sd">            &#39;main&#39;   --(default)  the utility (constant) of the &#39;route_type&#39; is used</span>

<span class="sd">            &#39;min&#39;    -- minimum of the utilities (constant) of the modes in route_types</span>

<span class="sd">            &#39;max&#39;   -- maximum of the utilities (constant) of the modes in route_types</span>

<span class="sd">            &#39;mean&#39;   -- mean of the utilities (constant) of the modes in route_types</span>

<span class="sd">            &#39;sum&#39;   -- sum of the utilities (constant) of the modes in route_types</span>

<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">utilities</span> <span class="o">=</span> <span class="p">[</span><span class="n">mode_utility</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">route_types</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">utilities</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>  <span class="c1"># worse mode</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">utilities</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>  <span class="c1"># best mode</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">utilities</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;sum&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">utilities</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">utilities</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">utilities</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Systra.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>